import json
import csv
import re

def parse_cvss_vector(cvss_vector):
    pattern = re.compile(r'([A-Z]+):([A-Z]+)')
    return dict(pattern.findall(cvss_vector))

def convert_nvd_json_to_csv(json_file, csv_file):
    with open(json_file, 'r',encoding='utf-8') as f:
        data = json.load(f)

    # Define the CSV columns
    csv_columns = [
        'cve_id', 'description', 'cvss_score',
        'AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A'
    ]

    with open(csv_file, 'w', newline='',encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=csv_columns)
        writer.writeheader()

        for item in data['CVE_Items']:
            cve_id = item['cve']['CVE_data_meta']['ID']
            description = item['cve']['description']['description_data'][0]['value']

            # Extract CVSS details
            cvss_score = None
            cvss_vector = None
            metrics = {}

            impact = item.get('impact')
            if impact:
                baseMetricV3 = impact.get('baseMetricV3')
                if baseMetricV3:
                    cvss_score = baseMetricV3['cvssV3']['baseScore']
                    cvss_vector = baseMetricV3['cvssV3']['vectorString']
                    metrics = parse_cvss_vector(cvss_vector)
                else:
                    baseMetricV2 = impact.get('baseMetricV2')
                    if baseMetricV2:
                        cvss_score = baseMetricV2['cvssV2']['baseScore']
                        cvss_vector = baseMetricV2['cvssV2']['vectorString']
                        metrics = parse_cvss_vector(cvss_vector)

            # Create the row for CSV
            row = {
                'cve_id': cve_id,
                'description': description,
                'cvss_score': cvss_score,
                'AV': metrics.get('AV', ''),
                'AC': metrics.get('AC', ''),
                'PR': metrics.get('PR', ''),
                'UI': metrics.get('UI', ''),
                'S': metrics.get('S', ''),
                'C': metrics.get('C', ''),
                'I': metrics.get('I', ''),
                'A': metrics.get('A', '')
            }

            writer.writerow(row)

json_file = 'D:\\project\\nvdcve.json'
csv_file = 'D:\\project\\output.csv' 

convert_nvd_json_to_csv(json_file, csv_file)


import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import joblib
import requests

# Step 1: Collect Dataset
dataset_path = 'D:project\\output.csv'
df = pd.read_csv(dataset_path)

# Step 2: Data Preprocessing
# Remove rows with null or empty vector string fields
df.dropna(subset=['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A'], inplace=True)
df = df[(df['AV'] != '') & (df['AC'] != '') & (df['PR'] != '') & (df['UI'] != '') &
        (df['S'] != '') & (df['C'] != '') & (df['I'] != '') & (df['A'] != '')]

# Convert categorical variables to dummy/indicator variables
df = pd.get_dummies(df, columns=['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A'])

# Separate features and labels
X = df.drop(columns=['cve_id', 'description', 'cvss_score'])
y = df['cvss_score']

# Step 3: Train a Machine Learning Model
# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a RandomForestRegressor
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate the model
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"Model Mean Squared Error: {mse:.2f}")
print(f"Model R-squared: {r2:.2f}")

# Save the trained model
joblib.dump(model, 'exploitability_model.pkl')

# Step 4: Predict CVSS Score
def get_cvss_score(cve_id):
    try:
        url = f'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}'
        response = requests.get(url)
        response.raise_for_status()

        cve_data = response.json()

        if cve_data and 'vulnerabilities' in cve_data:
            cve_item = cve_data['vulnerabilities'][0]['cve']
            metrics = cve_item.get('metrics', {}).get('cvssMetricV31', [])

            if not metrics:
                return None

            cvss_v3 = metrics[0].get('cvssData', {})
            vector_string = cvss_v3.get('vectorString', '')

            # Parse the vector string
            vector_components = vector_string.split('/')
            vector_dict = {}
            for component in vector_components[1:]:
                key, value = component.split(':')
                vector_dict[key] = value

            return {
                'AV': vector_dict.get('AV', ''),
                'AC': vector_dict.get('AC', ''),
                'PR': vector_dict.get('PR', ''),
                'UI': vector_dict.get('UI', ''),
                'S': vector_dict.get('S', ''),
                'C': vector_dict.get('C', ''),
                'I': vector_dict.get('I', ''),
                'A': vector_dict.get('A', ''),
            }
        else:
            return None
    except requests.exceptions.RequestException as e:
        print(f"An error occurred while retrieving CVE data: {e}")
        return None

def predict_cvss_score(cve_id):
    cve_data = get_cvss_score(cve_id)

    if cve_data is None or any(value == '' for value in cve_data.values()):
        return None

    # Load the trained model
    model = joblib.load('exploitability_model.pkl')

    # Prepare the feature vector for prediction
    feature_vector = pd.DataFrame([cve_data])
    feature_vector = pd.get_dummies(feature_vector, columns=['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A'])

    # Ensure the feature vector has the same columns as the training data
    for column in X.columns:
        if column not in feature_vector.columns:
            feature_vector[column] = 0

    # Reorder columns to match the training data
    feature_vector = feature_vector[X.columns]

    # Predict CVSS score
    prediction = model.predict(feature_vector)

    return prediction[0]

def suggest_remediation_action(cvss_score):
    if cvss_score >= 9.0:
        action = "Immediate attention and remediation required. Apply patches or mitigation measures urgently."
        severity = "Critical"
    elif cvss_score >= 7.0:
        action = "High priority for remediation. Plan and apply patches or mitigation measures as soon as possible."
        severity = "High"
    elif cvss_score >= 4.0:
        action = "Important to address, but may not require immediate action. Schedule remediation within a reasonable time frame."
        severity = "Medium"
    elif cvss_score >= 0.1:
        action = "Monitor and address as part of regular maintenance. Remediate based on business priorities and available resources."
        severity = "Low"
    else:
        action = "No action required."
        severity = "None"

    return severity, action

cve_id = input('Enter the CVE ID you want to predict CVSS score for:') # Note: Replace with the CVE ID you want to predict CVSS score for
cvss_score_prediction = predict_cvss_score(cve_id)

if cvss_score_prediction is not None:
    print(f"The predicted CVSS score for CVE {cve_id} is {cvss_score_prediction:.2f}.")
else:
    print(f"CVSS score prediction for {cve_id} is not available.")

cvss_score = cvss_score_prediction
severity, action = suggest_remediation_action(cvss_score)
print(f"Severity: {severity}")
print(f"Suggested Remediation Action: {action}")